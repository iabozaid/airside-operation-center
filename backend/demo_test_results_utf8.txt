============================= test session starts =============================
platform win32 -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0 -- c:\Projects\Riyadh Airport\venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Projects\Riyadh Airport\backend
configfile: pyproject.toml
plugins: anyio-4.12.1, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 3 items

tests/test_api_contracts.py::test_api_contracts FAILED                   [ 33%]
tests/test_api_contracts.py::test_fleet_lifecycle PASSED                 [ 66%]
tests/test_api_contracts.py::test_sse_sanity FAILED                      [100%]

================================== FAILURES ===================================
_____________________________ test_api_contracts ______________________________

    @pytest.mark.asyncio
    async def test_api_contracts():
        transport = ASGITransport(app=app)
    
        async with LifespanManager(app):
            async with AsyncClient(transport=transport, base_url="http://test") as ac:
                # 1. Login (Mandatory)
                headers = await login(ac)
    
                # -----------------------------------------------------------------
                # SOC Context
                # -----------------------------------------------------------------
                response = await ac.get("/incidents", headers=headers)
                assert response.status_code == 200
                data = response.json()
                assert isinstance(data, list)
    
                # Validate subset to stay performant
                for item in data[:10]:
                    validated = IncidentResponse(**item)
                    assert validated.id == item["id"]
    
                # -----------------------------------------------------------------
                # Fleet Context
                # -----------------------------------------------------------------
>               response = await ac.get("/fleet/assets", headers=headers)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_api_contracts.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\venv\Lib\site-packages\httpx\_client.py:1768: in get
    return await self.request(
..\venv\Lib\site-packages\httpx\_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_client.py:1629: in send
    response = await self._send_handling_auth(
..\venv\Lib\site-packages\httpx\_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
..\venv\Lib\site-packages\httpx\_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_transports\asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\venv\Lib\site-packages\starlette\applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
..\venv\Lib\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\venv\Lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\venv\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\venv\Lib\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\venv\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\venv\Lib\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\venv\Lib\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

service = <src.fleet.service.FleetService object at 0x0000028787BAAFD0>

    @router.get("/fleet/assets", response_model=List[AssetResponse])
    async def get_assets(service: FleetService = Depends(get_fleet_service)):
        assets = await service.list_assets()
        return [
            AssetResponse(
                id=str(row['id']), # Using DB ID logic? Or raw_id? Repo returns serialize_row which is DB ID. OK for MVP.
                asset_type=row.get('asset_type', 'unknown'),
                name=row.get('name', 'unknown'),
                status=row.get('status', 'unknown'),
                last_heartbeat_utc=row.get('last_heartbeat') # Pydantic handles datetime
>           ) for row in assets
                         ^^^^^^
        ]
E       TypeError: 'NoneType' object is not iterable

src\fleet\adapters\api.py:21: TypeError
---------------------------- Captured stdout call -----------------------------
[WARN] Schema file not found at C:\Projects\Riyadh Airport\backend\src\infrastructure\schema.sql. Skipping init.
------------------------------ Captured log call ------------------------------
WARNING  src.shared.event_bus:event_bus.py:64 [DEMO MODE] Redis disabled. Using In-Memory Event Bus.
WARNING  src.shared.consumers:consumers.py:157 [DEMO MODE] Starting In-Memory Consumers (No Redis).
_______________________________ test_sse_sanity _______________________________

    async def read_sse() -> bool:
>       async with ac.stream("GET", SSE_STREAM_PATH, headers=headers) as response:
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_api_contracts.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python314\Lib\contextlib.py:214: in __aenter__
    return await anext(self.gen)
           ^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_client.py:1583: in stream
    response = await self.send(
..\venv\Lib\site-packages\httpx\_client.py:1629: in send
    response = await self._send_handling_auth(
..\venv\Lib\site-packages\httpx\_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
..\venv\Lib\site-packages\httpx\_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_transports\asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\venv\Lib\site-packages\starlette\applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
..\venv\Lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\venv\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\venv\Lib\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\venv\Lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\venv\Lib\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\venv\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\venv\Lib\site-packages\fastapi\routing.py:102: in app
    await response(scope, receive, send)
..\venv\Lib\site-packages\starlette\responses.py:270: in __call__
    async with anyio.create_task_group() as task_group:
               ^^^^^^^^^^^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\anyio\_backends\_asyncio.py:787: in __aexit__
    raise exc_val
..\venv\Lib\site-packages\starlette\responses.py:277: in __call__
    await wrap(partial(self.listen_for_disconnect, receive))
..\venv\Lib\site-packages\starlette\responses.py:273: in wrap
    await func()
..\venv\Lib\site-packages\starlette\responses.py:241: in listen_for_disconnect
    message = await receive()
              ^^^^^^^^^^^^^^^
..\venv\Lib\site-packages\httpx\_transports\asgi.py:138: in receive
    await response_complete.wait()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <asyncio.locks.Event object at 0x0000028788742030 [unset]>

    async def wait(self):
        """Block until the internal flag is true.
    
        If the internal flag is true on entry, return True
        immediately.  Otherwise, block until another task calls
        set() to set the flag to true, then return True.
        """
        if self._value:
            return True
    
        fut = self._get_loop().create_future()
        self._waiters.append(fut)
        try:
>           await fut
E           asyncio.exceptions.CancelledError

C:\Python314\Lib\asyncio\locks.py:213: CancelledError

The above exception was the direct cause of the following exception:

    @pytest.mark.asyncio
    async def test_sse_sanity():
        """
        Connects to SSE stream and waits for a single event to verify envelope.
        Deterministically triggers an event first to ensure stream has data.
        """
        transport = ASGITransport(app=app)
    
        async with LifespanManager(app):
            async with AsyncClient(transport=transport, base_url="http://test") as ac:
                headers = await login(ac)
    
                # 1. Trigger Simulation Event (Overspeed)
                sim_resp = await ac.post(SIM_OVERSPEED_PATH, headers=headers)
                assert sim_resp.status_code == 200, f"Simulation trigger failed: {sim_resp.text}"
    
                # 2. Connect and Read with Timeout
                async def read_sse() -> bool:
                    async with ac.stream("GET", SSE_STREAM_PATH, headers=headers) as response:
                        assert response.status_code == 200
                        assert response.headers.get("content-type", "").startswith("text/event-stream")
    
                        async for line in response.aiter_lines():
                            # Robust parsing: handle 'data:' with or without space
                            if line.startswith("data:"):
                                payload_json = line[5:].strip()
                                if not payload_json:
                                    continue
    
                                try:
                                    data = json.loads(payload_json)
                                except json.JSONDecodeError:
                                    continue
    
                                keys = data.keys()
    
                                # Identify keys
                                event_type = data.get("event_type") or data.get("eventType") or data.get("type")
                                correlation_id = data.get("correlation_id") or data.get("correlationId")
    
                                has_timestamp = any(k in keys for k in [
                                    "timestamp", "timestamp_utc", "timestampUtc",
                                    "created_at_utc", "createdAtUtc"
                                ])
    
                                # Verification Logic
                                if event_type:
                                    # Wait for specific event if typed
                                    if event_type == "fleet.overspeed_detected":
                                        return True
                                    # Otherwise ignore other events
                                    continue
    
                                # If untyped, accept any valid envelope shape
                                if correlation_id and has_timestamp:
                                    return True
    
                    return False
    
                try:
                    # 5 second timeout for deterministic failure
>                   success = await asyncio.wait_for(read_sse(), timeout=5.0)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_api_contracts.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python314\Lib\asyncio\tasks.py:487: in wait_for
    async with timeouts.timeout(timeout):
               ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Timeout [expired]>
exc_type = <class 'asyncio.exceptions.CancelledError'>
exc_val = CancelledError(), exc_tb = <traceback object at 0x000002878859FA00>

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: TracebackType | None,
    ) -> bool | None:
        assert self._state in (_State.ENTERED, _State.EXPIRING)
    
        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None
    
        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED
    
            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

C:\Python314\Lib\asyncio\timeouts.py:114: TimeoutError

During handling of the above exception, another exception occurred:

    @pytest.mark.asyncio
    async def test_sse_sanity():
        """
        Connects to SSE stream and waits for a single event to verify envelope.
        Deterministically triggers an event first to ensure stream has data.
        """
        transport = ASGITransport(app=app)
    
        async with LifespanManager(app):
            async with AsyncClient(transport=transport, base_url="http://test") as ac:
                headers = await login(ac)
    
                # 1. Trigger Simulation Event (Overspeed)
                sim_resp = await ac.post(SIM_OVERSPEED_PATH, headers=headers)
                assert sim_resp.status_code == 200, f"Simulation trigger failed: {sim_resp.text}"
    
                # 2. Connect and Read with Timeout
                async def read_sse() -> bool:
                    async with ac.stream("GET", SSE_STREAM_PATH, headers=headers) as response:
                        assert response.status_code == 200
                        assert response.headers.get("content-type", "").startswith("text/event-stream")
    
                        async for line in response.aiter_lines():
                            # Robust parsing: handle 'data:' with or without space
                            if line.startswith("data:"):
                                payload_json = line[5:].strip()
                                if not payload_json:
                                    continue
    
                                try:
                                    data = json.loads(payload_json)
                                except json.JSONDecodeError:
                                    continue
    
                                keys = data.keys()
    
                                # Identify keys
                                event_type = data.get("event_type") or data.get("eventType") or data.get("type")
                                correlation_id = data.get("correlation_id") or data.get("correlationId")
    
                                has_timestamp = any(k in keys for k in [
                                    "timestamp", "timestamp_utc", "timestampUtc",
                                    "created_at_utc", "createdAtUtc"
                                ])
    
                                # Verification Logic
                                if event_type:
                                    # Wait for specific event if typed
                                    if event_type == "fleet.overspeed_detected":
                                        return True
                                    # Otherwise ignore other events
                                    continue
    
                                # If untyped, accept any valid envelope shape
                                if correlation_id and has_timestamp:
                                    return True
    
                    return False
    
                try:
                    # 5 second timeout for deterministic failure
                    success = await asyncio.wait_for(read_sse(), timeout=5.0)
                    assert success, "Stream stayed open but no valid target event received"
                except asyncio.TimeoutError:
>                   pytest.fail("SSE Stream timed out after 5 seconds")
E                   Failed: SSE Stream timed out after 5 seconds

tests\test_api_contracts.py:190: Failed
---------------------------- Captured stdout call -----------------------------
[WARN] Schema file not found at C:\Projects\Riyadh Airport\backend\src\infrastructure\schema.sql. Skipping init.
------------------------------ Captured log call ------------------------------
WARNING  src.shared.event_bus:event_bus.py:64 [DEMO MODE] Redis disabled. Using In-Memory Event Bus.
WARNING  src.shared.consumers:consumers.py:157 [DEMO MODE] Starting In-Memory Consumers (No Redis).
============================== warnings summary ===============================
src\soc\schemas.py:20
  C:\Projects\Riyadh Airport\backend\src\soc\schemas.py:20: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    updated_at_utc: datetime = datetime.utcnow()

src\main.py:35
  C:\Projects\Riyadh Airport\backend\src\main.py:35: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

..\venv\Lib\site-packages\fastapi\applications.py:4576
..\venv\Lib\site-packages\fastapi\applications.py:4576
  c:\Projects\Riyadh Airport\venv\Lib\site-packages\fastapi\applications.py:4576: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

src\main.py:54
  C:\Projects\Riyadh Airport\backend\src\main.py:54: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("shutdown")

tests/test_api_contracts.py::test_api_contracts
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_sse_sanity
tests/test_api_contracts.py::test_sse_sanity
tests/test_api_contracts.py::test_sse_sanity
  C:\Projects\Riyadh Airport\backend\src\shared\event_bus.py:96: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    timestamp = datetime.utcnow().isoformat()

tests/test_api_contracts.py::test_api_contracts
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_fleet_lifecycle
tests/test_api_contracts.py::test_sse_sanity
tests/test_api_contracts.py::test_sse_sanity
tests/test_api_contracts.py::test_sse_sanity
  C:\Projects\Riyadh Airport\backend\src\shared\event_bus.py:90: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    ts = int(datetime.utcnow().timestamp() * 1000)

tests/test_api_contracts.py::test_sse_sanity
  C:\Projects\Riyadh Airport\backend\src\simulation\control_router.py:28: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    timestamp = datetime.datetime.utcnow().isoformat()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_api_contracts.py::test_api_contracts - TypeError: 'NoneType' object is not iterable
FAILED tests/test_api_contracts.py::test_sse_sanity - Failed: SSE Stream timed out after 5 seconds
================== 2 failed, 1 passed, 20 warnings in 12.99s ==================
